# 网络相关知识点

## 1. HTTPS 协议，为什么 HTTPS 更安全？

### 1.1 HTTPS 简介
- **HTTPS = HTTP + SSL/TLS**，是在 HTTP 协议基础上通过 SSL/TLS 实现加密传输的安全协议。
- 主要用于保障客户端与服务器之间的数据安全。

### 1.2 HTTPS 的核心目标
- **加密**：防止中间人窃听明文数据（如密码、token）。
- **身份认证**：确保客户端访问的服务器是真实的，防止钓鱼网站。
- **数据完整性**：防止数据在传输过程中被篡改。

### 1.3 HTTPS 的工作流程（简化版）
1. **客户端发起请求**：浏览器访问 https:// 网站，发起 SSL/TLS 握手。
2. **服务器返回证书**：服务器将自己的公钥证书（包含公钥、颁发者信息等）返回给客户端。
3. **客户端验证证书合法性**：检查证书是否被信任的 CA 签发、域名是否匹配、证书是否过期。
4. **协商对称加密密钥**：客户端生成对称密钥，用服务器的公钥加密后发给服务器，只有服务器的私钥能解密。
5. **数据通信使用对称加密**：双方都拥有同一个对称加密密钥，之后的 HTTP 通信内容就是加密的。

### 1.4 HTTPS 比 HTTP 更安全的 3 个核心原因
#### ① 通信加密（Confidentiality）
- **HTTP**：明文传输，任何中间人（如 Wi-Fi 热点、运营商）都可以看到请求内容（用户名、密码、token、表单数据等）。
- **HTTPS**：使用对称加密（如 AES），通信内容被加密，即使被拦截也无法读取。

#### ② 身份认证（Authentication）
- **HTTPS**：使用数字证书（由权威 CA 签发）来证明服务器真实身份。
- 客户端在握手时会验证服务器证书是否合法、域名是否一致、是否过期，防止钓鱼网站。

#### ③ 数据完整性保护（Integrity）
- **HTTPS**：通信过程中使用消息摘要算法（如 SHA-256）和 MAC 校验，确保数据未被中间人篡改。
- 即使攻击者劫持了数据，也无法对内容进行修改而不被发现。

### 1.5 HTTPS 与 HTTP 的区别
| 方面     | HTTP                | HTTPS                          |
| -------- | ------------------- | ------------------------------ |
| 安全性   | 明文传输，不安全     | 加密传输，防窃听、防篡改        |
| 端口     | 默认使用 80         | 默认使用 443                   |
| 证书支持 | 不需要              | 需要 SSL 证书（可付费或免费）   |
| 性能     | 较快                | TLS 握手阶段略慢，现已优化      |

### 1.6 开发者关注点
- **HSTS（HTTP Strict Transport Security）**：防止协议降级攻击。后端可以在响应头中设置 Strict-Transport-Security，强制客户端始终用 HTTPS
- **Mixed Content 警告**：页面使用 HTTPS，但引用了 HTTP 的资源（如图片、脚本）会被浏览器阻止或警告
- **证书更新/自动化**：Let’s Encrypt 提供免费证书，搭配自动化工具（如 Certbot）进行更新，降低维护成本
- 浏览器地址栏出现 🔒 锁标志，表示当前网站可信、连接加密

---

## 2. HTTP 缓存

### 2.1 强缓存
- 不请求服务器，直接使用本地缓存
#### 响应头
1. **Cache-Control**
- 是现代浏览器主要的缓存控制方式，优先级高于Expires
- 常见指令：
  - max-age=3600: 缓存有效期为 3600 秒
  - no-store：禁止缓存
  - no-cache：允许缓存但必须向服务器验证
  - public：可被任何中间缓存服务器缓存
  - private：仅浏览器缓存，CDN 不可缓存
2. **Expires**
- 老版本 HTTP/1.0 使用，指定一个绝对时间（GMT 格式），超出则缓存失效
- 和 max-age 不同，容易受客户端时间影响
### Cache-control示例
1. **Cache-Control: public, max-age=31536000, immutable**
- **public**：允许中间缓存（CDN、浏览器）缓存
- **max-age=31536000**：缓存 1 年（秒为单位）
- **immutable**：表明资源永远不会改变，浏览器不会发起条件请求
2. **Cache-Control: private, max-age=600**
- **private**：缓存仅对用户的浏览器有效，中间缓存（如 CDN）不能缓存
- **max-age=600**：浏览器可缓存 10 分钟
3. **Cache-Control: public**
- 缓存是否生效取决于其他缓存头（如 Expires、ETag）
### 判断方式
- 浏览器访问资源时，如果强缓存生效，不会向服务器发请求，状态码为 200 (from disk cache) 或 200 (from memory cache)

### 2.2 协商缓存
- 发送请求，服务器确认是否需要重新下载
- 当强缓存失效后，浏览器会向服务器发起请求，并带上上一次缓存的标识信息，服务器判断资源是否变更
### 请求头和响应头
1. **Last-Modified（响应头） 和 If-Modified-Since（请求头）**
- 服务端返回资源的最后修改时间
- 下次请求时，浏览器带上 If-Modified-Since
- 服务端比较修改时间是否有变，如果没变返回 304，否则返回新资源
2. **ETag（响应头） 和 If-None-Match（请求头）**
- ETag 是资源内容的唯一标识符（可以是哈希
- 浏览器下次请求带上 If-None-Match，服务端验证是否一致
- 一致则返回 304；否则返回新内容并更新 ETag
>**⚠️ 注意：** 相比 Last-Modified，ETag 更准确，即使资源时间未变但内容有小改动，也能识别。

### 强缓存和协商缓存的关系
#### 浏览器缓存流程顺序：
1. **先查强缓存（Cache-Control / Expires）**
- 命中 → 直接使用
2. **强缓存失效后走协商缓存（ETag / Last-Modified）**
- 若资源未变 → 服务器返回 304 → 浏览器使用本地缓存
- 若资源已变 → 服务器返回 200 → 浏览器更新缓存

### 开发中的延伸点
- 即使服务器返回了 ETag 和 Last-Modified，只有当强缓存失效（如 max-age 到期）后，浏览器才会走协商缓存
- 如果资源设置了长效 Cache-Control: max-age=31536000，就算有 ETag，通常也不会走协商缓存
- 浏览器缓存策略由多因素共同决定，不仅是响应头，还和用户行为、开发者工具（Disable Cache）、缓存空间策略等有关

---

## 3. DNS 解析涉及到的协议
### 相关协议
1. **UDP协议**
- 默认是使用的传输层协议
- DNS查询的首选协议，端口号：53
- 原因：UDP 是无连接的，开销小、速度快，适合简单的一问一答场景
- 特点：数据包小于 512 字节（传统 DNS，IPv4 环境），客户端向 DNS 服务器发起请求，服务器直接返回结果
2. **TCP协议**
- 当以下情况发生时，DNS 会自动从 UDP 切换为 TCP：
  - 响应数据超过 UDP 限制（现代支持 EDNS，可达 4096 字节，但仍有上限）
  - 进行区域传输（zone transfer）时，必须使用 TCP
  - 某些 DNS 查询要求可靠性保障（如 DNSSEC）
3. **IP协议**
- DNS 请求和响应最终通过 IP 协议在网络上传输
- IPv4 or IPv6 决定了目标 DNS 服务器的寻址方式
4. **ICMP协议**
- 不直接用于 DNS 解析
- 但在排查 DNS 失败或网络延迟时（如 ping、traceroute）经常用于辅助诊断
- 有助于了解 DNS 请求到底卡在哪一跳（比如 ping 不通 DNS 服务器）
### DNS解析过程
1. **本地缓存检查**
- **浏览器 DNS 缓存**：如 Chrome 自带的缓存（可查看 chrome://net-internals/#dns）
- **操作系统缓存**：如 Windows 的 DNS 缓存 (ipconfig /displaydns)
- **本地 Hosts 文件**：/etc/hosts 或 C:\Windows\System32\drivers\etc\hosts
2. **本地DNS服务器**
- 通常是你所在网络提供的 DNS（如 114.114.114.114、8.8.8.8），它会帮你递归查找最终 IP，返回结果后缓存一段时间
3. **根域名服务器**
- 如果本地 DNS 服务器也没缓存，它会问全球 13 个 根 DNS 服务器，返回 .com 顶级域服务器地址
4. **顶级域名服务器（TLD）**
- 返回 example.com 的权威服务器地址
5. **权威 DNS 服务器**
- 返回 www.example.com 对应的 IP 地址
6. **总结**
- DNS 解析是将域名转换为 IP 地址的过程，浏览器会先查本地缓存，如果没有命中，就向递归 DNS 服务器发起查询，再由它逐级从根服务器、TLD 服务器、权威服务器查询 IP 地址，最终返回结果并缓存。DNS 查询是浏览器访问网站的第一步，对性能有重要影响。DNS 查询是性能优化关键（可结合 DNS 预获取 `<link rel="dns-prefetch">`）

---

## 4. 应用层的协议
HTTP、HTTPS、FTP、SMTP、POP3、IMAP、DNS、WebSocket 等
1. **Web 通信相关**
- **✅HTTP / HTTPS**
- 用途：浏览器与服务器之间通信的主流协议
- 端口：80（HTTP），443（HTTPS）
- 特性：
  - 基于请求/响应模型
  - 无状态
  - 支持 GET、POST、PUT、DELETE 等方法
- **✅WebSocket**
- 用途：实现浏览器与服务器之间的双向通信（长连接）
- 端口：通常也是 80（ws）或 443（wss）
- 特性：
  - 建立在 HTTP 基础之上，通过升级协议握手
  - 支持实时应用，如聊天室、股票行情、游戏等 
2. **文件传输 / 下载相关**
- **✅FTP（File Transfer Protocol）**
- 用途：在服务器和客户端之间传输文件
- 端口：21（控制连接），20（数据连接）
- 特点：
  - 明文传输（有安全隐患），可用 FTPS/SFTP 加密
  - 常用于网站部署、资源同步
- **✅HTTP(S) 下载**
- 虽不是专用文件协议，但现代大部分文件下载也通过 HTTP(S)
3. **邮件相关**
- **✅SMTP（Simple Mail Transfer Protocol）**
- 用途：用于发送邮件
- 端口：25、465（SSL）、587（STARTTLS）
- **✅POP3 / IMAP**
- POP3（端口 110）：邮件拉取到本地后服务器删除
- IMAP（端口 143）：服务器保留副本，支持多设备同步查看邮件
4. **域名解析 / 网络服务**
- **✅DNS（Domain Name System）**
- 用途：将域名解析为 IP 地址
- 端口：53（UDP/TCP）
- 扩展：支持加密版本 DoH（HTTPS）、DoT（TLS）

---

## 5. UDP 协议
✅ 一句话概括： UDP（User Datagram Protocol）是传输层的无连接协议，特点是速度快、开销小，但不保证可靠性
1. **基本特点**
- **无连接**：不建立连接，直接发送数据（不像 TCP 三次握手）
- **不可靠**：不保证数据一定送达，也不保证顺序和去重
- **面向报文**：一次发送一个完整数据包，应用需自行处理分片
- **速度快**： 没有连接管理和重传机制，延迟小、效率高
- **无拥塞控制**： 不主动限流，适合实时场景但可能丢包
2. **工作方式**
- 不需要建立连接，直接发送数据包到目标地址和端口
- 每个数据包叫做“报文段（datagram）”
- 接收方收到的可能是乱序的、重复的、甚至收不到（丢包）
- 没有流量控制和拥塞控制，完全靠应用层控制逻辑
3. **典型应用场景**
- **DNS 查询**：体积小，速度要求高
- **视频直播**：偶尔丢帧也可接受，实时性重要
- **VoIP 通话**：对实时性要求高，不适合重传
- **在线游戏**：响应快优于可靠传输
- **DHCP 协议**： 网络初始化期间使用 UDP 广播
4. **UDP vs TCP**

| 特性         | UDP                          | TCP                              |
| ------------ | --------------------------- | --------------------------------- |
| 是否连接     | ❌ 无连接                     | ✅ 面向连接（三次握手）            |
| 可靠性       | ❌ 不保证可靠、不保证顺序      | ✅ 保证可靠、有序、无重复传输      |
| 速度         | ✅ 快，延迟低                  | ❌ 相对慢，需连接和确认            |
| 拥塞/流量控制 | ❌ 无                         | ✅ 有                              |
| 报文大小限制 | 单个报文 ≤ 65,535 字节        | 自动分段，理论无限                |
| 应用场景     | 实时性优先（直播、游戏、DNS） | 可靠性优先（网页、文件、邮件等

5. **前端视角下如何“接触”到 UDP**
- DNS 查询（大多数用 UDP）
- WebRTC：浏览器的实时音视频通信，底层基于 UDP + SRTP
- CDN 加速 / 视频直播：UDP 提供低延迟传输，前端体验依赖 UDP 质量
- 网络诊断工具：如 ping、traceroute 有时依赖 UDP 包探测

---

## 6. TCP 三次握手，为什么一定需要三次握手？
✅ 一句话概括： 三次握手的本质目的是 确保客户端和服务器双方都有“接收”和“发送”能力正常，确保连接的可靠性。
### 三次握手流程
1. **第一次握手**（客户端 → 服务器）
- 客户端发送一个带 SYN 标志位的报文，请求建立连接（我能发送）。
2. **第二次握手**（服务器 → 客户端）
- 服务器收到请求，返回一个 SYN + ACK 报文，表示（确认客户端能发送）：
  - 收到了客户端的 SYN（我能接收）
  - 自己也发起了连接请求（我能发送） 
3. **第三次握手**（客户端 → 服务器）
- 客户端收到 SYN+ACK 后，发送一个 ACK 报文，表示（确认服务端能接受和发送）：
  - 收到服务器的响应（我能接收）
  - 确认连接可以正式建立 

### 为什么不能两次握手
假设：只有两次握手
- 第一次：客户端发送 SYN
- 第二次：服务器收到，回复 SYN+ACK
- 没有第三次，客户端不再响应  
此时，服务器不知道客户端是否收到了自己发的 SYN+ACK，也不知道客户端是否准备好收发数据。  
⚠️ 这可能会导致：
- 服务器误以为连接已建立（而客户端实际未确认）
- 服务器为这个连接分配资源，但客户端并未准备好使用
- 导致资源浪费，甚至成为攻击点（例如 SYN Flood 攻击）

### 为什么不是四次握手
实际上 三次就足够，因为：
- 第二次握手中，服务器就已经同时完成了两个动作
  - 确认客户端的连接请求（ACK）
  - 发起自己的连接请求（SYN）
- 如果把 ACK 和 SYN 拆成两次，那确实就会变成四次握手，但效率更低，而没有必要

---

## 7. 在浏览器输入url后发生了什么
### 7.1 总览
1）URL解析 → 2）DNS解析 → 3）TCP连接（含TLS） → 4）发送HTTP请求 → 5）服务器响应 → 6）浏览器解析渲染页面 → 7）可能的二次请求
### 7.2 详细步骤
1. URL 解析
- 浏览器检查 URL 格式，如是否为 http(s)、是否带端口、路径、查询参数
- 如果是输入关键词（如 “百度”），浏览器会重定向搜索引擎
2. DNS解析
- 浏览器先查 本地缓存（浏览器 → 操作系统 → hosts 文件）
- 查不到则询问 DNS 服务器（递归或迭代方式）
- 得到目标主机 IP 地址（如：93.184.216.34）
3. 建立TCP链接
- 使用三次握手
- 若是 https，则在此基础上还要进行 TLS 握手
  - 协商加密算法
  - 验证服务器证书
  - 交换密钥
4. 发送HTTP请求
- 构建并发送完整的 HTTP 请求数据包
5. 服务器处理请求并响应
- 服务端接收到请求，交由后端程序处理
- 查询数据库、渲染 HTML、准备资源
- 返回 HTTP 响应
6. 浏览器接收并渲染页面
- HTML → 解析成 DOM Tree
- CSS → 解析成 CSS Tree
- Layout（计算位置）
- Paint（绘制像素）
- Composite（合成位图）

---

## 8. HTTP 请求和SSE 请求区别
### 一句话总结
- HTTP 请求是客户端主动发起、一次一回应的单向通信方式
- SSE 是服务端主动推送数据给客户端的持久连接机制，适用于实时数据更新场景。
### 核心区别对比
| 对比项                | HTTP 请求           | SSE（Server-Sent Events）      |
| ------------------ | ----------------- | ---------------------------- |
| **连接方式**           | 短连接（一次请求一次响应）     | 单向长连接（客户端连接，服务端持续推送）         |
| **协议**             | HTTP/1.x, HTTP/2  | HTTP（普通协议，无需额外支持）            |
| **通信方向**           | 客户端 → 服务端         | 服务端 → 客户端                    |
| **消息格式**           | 任意数据格式（JSON/HTML） | 文本数据，使用特定格式 `data:` + `\n\n` |
| **推送机制**           | 无（需要轮询或手动请求）      | 服务端主动推送                      |
| **适合场景**           | 表单提交、接口查询等传统请求    | 实时通知、日志流、监控数据、股票数据等          |
| **浏览器支持**          | 所有浏览器             | 大多数现代浏览器支持（IE 不支持）           |
| **连接数限制**          | 没限制（每次请求新建连接）     | 每个客户端通常维持一个连接                |
| **客户端断线自动重连**      | 需手动实现             | ✅ 默认支持断线自动重连                 |
| **服务端实现复杂度**       | 简单                | 简单（无需 WebSocket 的握手和升级协议）    |
| **跨域支持**           | 需配置 CORS          | 也需配置 CORS                    |
| **与 WebSocket 区别** | 单次请求              | 单向持久连接，轻量级 WebSocket 替代方案    |
### 请求流程对比
1. http请求：
- 客户端发起请求 → 服务端处理 → 返回响应 → 连接关闭
2. SSE 请求流程
- 客户端发起 EventSource 连接 → 服务端保持连接不断开 → 服务端按需推送消息（data:\n\n 格式）→ 客户端监听 message 事件实时接收

---

## 9. HTTP/2 解决 HTTP/1.1什么问题
### 一句话总结
HTTP/2 通过“多路复用 + 二进制帧 + 头部压缩”等机制，解决了 HTTP/1.1 的队头阻塞、连接复用差、头部冗余等问题，从而大幅提升了性能和并发能力
### HTTP/1.1的核心问题
| 问题                            | 描述                                        |
| ----------------------------- | ----------------------------------------- |
| ❶ 队头阻塞（Head-of-line Blocking） | 同一个 TCP 连接内，只能串行发送请求，一个慢请求会阻塞后续所有请求       |
| ❷ 多连接开销大                      | 浏览器为提升并发，需开启多个 TCP 连接（如最多6个）来并发请求，增加系统负载  |
| ❸ 请求头冗余大                      | 每个请求都带上大量重复的 Header，如 Cookie、User-Agent 等 |
| ❹ 不支持请求优先级                    | 无法控制重要资源（如 CSS）优先加载                       |
| ❺ 无法主动推送资源                    | 服务端无法主动发送资源，必须等客户端请求                      |
### HTTP2如何解决这些问题
| HTTP/1.1 问题 | HTTP/2 解决方案          |
| ----------- | -------------------- |
| 多请求阻塞       | ✅ 多路复用（Multiplexing） |
| 连接数限制       | ✅ 1 个 TCP 连接即可并发多个请求 |
| Header 冗余   | ✅ 头部压缩（HPACK）        |
| 优先级控制差      | ✅ 请求支持优先级和依赖树        |
| 无服务端推送      | ✅ Server Push 支持     |
### 重点术语
1. 多路复用（Multiplexing）
- 多个请求/响应共享一个 TCP 连接，通过“流 ID”区分，实现并发传输、互不阻塞。
- HTTP/1.1：串行传输，请求 A 不返回，B 就要等着 → 队头阻塞
- HTTP/2：所有请求打包成帧，并行发送、并行解析
2. 二进制分帧机制
- 把 HTTP 报文分割成“帧”（Frame）：HEADERS、DATA 等
- 每帧携带“流 ID”，在一个 TCP 连接里混合传输
- 服务端再按帧拼接还原响应
3. 头部压缩（HPACK）
- 利用字典压缩技术压缩 HTTP Header，尤其像 Cookie 等重复字段，显著降低带宽开销
4. 服务端推送（Server Push）
- 服务端可以在响应主文档时，预先推送其他资源（如 CSS、JS），无需客户端再发起请求

--- 

## 10. 请求头中包含哪些重要信息
### 10.1 按功能分类常见重要请求头
| 类别       | 请求头                         | 描述                               |
| -------- | --------------------------- | -------------------------------- |
| **通用信息** | `Host`                      | 请求的主机名（必须字段）                     |
|          | `Connection`                | 控制连接方式，常见值：`keep-alive`, `close` |
|          | `Content-Length`            | 请求体长度（POST、PUT等会有）               |
|          | `Date`                      | 请求发起时间                           |
|          | `Upgrade-Insecure-Requests` | 告知服务器是否支持将 HTTP 升级为 HTTPS        |
|          | `Referer`                   | 表示请求的来源页面（用于防盗链、统计）              |
|          | `Origin`                    | 发起请求的源（协议 + 域 + 端口），用于 CORS 判断   |
|          | `User-Agent`                | 标识客户端信息（浏览器、操作系统等）               |
### 10.2 与缓存相关的请求头（强缓存 & 协商缓存）
| 请求头                 | 描述                                    |
| ------------------- | ------------------------------------- |
| `Cache-Control`     | 控制缓存策略，如 `no-cache`, `max-age=3600` 等 |
| `If-Modified-Since` | 和 `Last-Modified` 配合使用，基于修改时间的协商缓存    |
| `If-None-Match`     | 和 `ETag` 配合使用，基于内容哈希的协商缓存             |
| `Pragma`            | HTTP/1.0 中用于禁用缓存（已过时）                 |
### 10.3 与内容协商相关的请求头
| 请求头               | 描述                                                                 |
| ----------------- | ------------------------------------------------------------------ |
| `Accept`          | 告知服务器可接受的 MIME 类型（如 `text/html`, `application/json`）               |
| `Accept-Encoding` | 可接受的压缩编码方式（如 `gzip`, `br`）                                         |
| `Accept-Language` | 客户端希望的语言格式（如 `zh-CN`, `en-US`）                                     |
| `Content-Type`    | 请求体内容类型（如 `application/json`, `application/x-www-form-urlencoded`） |
### 10.4 与身份认证、安全相关的请求头
| 请求头                | 描述                                         |
| ------------------ | ------------------------------------------ |
| `Authorization`    | 认证信息，如 `Bearer token`, `Basic base64(...)` |
| `Cookie`           | 携带当前域名下的所有 cookie                          |
| `X-Requested-With` | 常见值 `XMLHttpRequest`，用于区分是 Ajax 请求         |
| `X-CSRF-Token`     | 防止跨站请求伪造（CSRF）攻击时附带的 token                 |

---

## 11. 如何通过请求头实现跨域资源共享
### 11.1 什么是跨域
当浏览器发出的请求 协议 + 域名 + 端口 三者任意不同 时，就构成跨域
### 11.2 CORS 的核心机制：通过请求头 + 响应头协作实现
#### 请求头
| 请求头名                             | 作用                                    |
| -------------------------------- | ------------------------------------- |
| `Origin`                         | 表示请求来源，浏览器自动添加（如：`http://a.com:8080`） |
| `Access-Control-Request-Method`  | 预检请求（OPTIONS）中声明实际方法（如 POST）          |
| `Access-Control-Request-Headers` | 预检中列出将要使用的自定义请求头                      |
#### 服务端响应头
| 响应头名                               | 作用                               |
| ---------------------------------- | -------------------------------- |
| `Access-Control-Allow-Origin`      | ✅ 指定允许的源（如 `http://a.com` 或 `*`） |
| `Access-Control-Allow-Methods`     | 允许的 HTTP 方法（如 `GET, POST, PUT`）  |
| `Access-Control-Allow-Headers`     | 允许客户端请求时携带的自定义请求头                |
| `Access-Control-Allow-Credentials` | 是否允许携带 Cookie（需搭配具体域名）           |
| `Access-Control-Max-Age`           | 预检请求的缓存时间（单位：秒）                  |
### 11.3 两类跨域请求：简单请求 vs 预检请求
1. 简单请求（不会触发 OPTIONS）
- 方法是 GET、POST、HEAD
- 请求头仅包含如下几种：Accept, Content-Type, Origin, User-Agent, Referer 等
- Content-Type 为
  - application/x-www-form-urlencoded
  - multipart/form-data
  - text/plain 
2. 预检请求（会触发 OPTIONS）
- 使用 PUT、DELETE 等方法
- 设置了自定义请求头（如 X-Token、Authorization）
- Content-Type 为 application/json
- 则浏览器会先发出一个 OPTIONS 请求，服务端响应后才继续发正式请求。
- 预检响应204 No Content
### 关键点
- 请求头中必须有 Origin，是浏览器自动加的
- 若有自定义头或 application/json，会触发预检
- 服务端必须响应 Access-Control-Allow-* 头，告诉浏览器允许跨域
- 若发送 Cookie，必须同时设置 credentials: include 和 Allow-Credentials: true
- Access-Control-Allow-Origin 不能为 *，必须是具体的源地址

---

## 12. 讲一下token、session和cookie
### 12.1 核心定义
| 项目          | 简述                                              |
| ----------- | ----------------------------------------------- |
| **Cookie**  | 浏览器保存的一小段文本数据，自动附带在每次请求中，由服务端或前端设置，用于识别用户       |
| **Session** | 服务端记录的用户会话状态，通常基于 Cookie 中的 `session_id` 进行查找   |
| **Token**   | 一段加密字符串，代表用户身份，由前后端约定生成，通常存储在前端（如 localStorage） |
### 12.2 它们之间的关系
- 浏览器请求 → 服务端生成 session → 将 session_id 写入 cookie 返回
- 下次请求 → 浏览器自动携带 cookie → 服务端读取 session_id → 获取 session

- 浏览器请求 → 登录成功 → 服务端生成 token 返回 → 前端保存 token
- 下次请求 → 前端将 token 放入 Authorization 请求头 → 服务端验证
### 12.3 三者对比总结表格
| 对比项     | Cookie             | Session                   | Token                      |
| ------- | ------------------ | ------------------------- | -------------------------- |
| 存储位置    | 客户端（浏览器）           | 服务端                       | 客户端（localStorage / Cookie） |
| 生命周期    | 可设置过期时间            | 通常在服务端内存中，默认临时            | 一般有明确的过期时间                 |
| 是否自动携带  | ✅ 每次请求自动携带         | ⛔ 不直接携带                   | ⛔ 需手动添加到请求头                |
| 跨域支持    | ⛔ 默认不支持（需设置 CORS）  | ⛔ 和 cookie 绑定             | ✅ 前端控制，灵活                  |
| 服务端是否存储 | ⛔ 只在客户端            | ✅ 存储所有会话数据                | ⛔ 不存储，服务端只验证               |
| 安全性     | 易被拦截（需配合 HttpOnly） | 较安全，但占用服务器内存              | 签名校验，防篡改，可防 CSRF           |
| 是否支持分布式 | ❌ 单机可行，分布式需共享      | ❌ 分布式时需 Session 共享或 Redis | ✅ 天然支持                     |
| 典型使用场景  | 用户偏好、自动登录          | 传统服务端登录会话管理               | 前后端分离、移动端、微服务              |

