# 网络相关知识点

## 1. HTTPS 协议，为什么 HTTPS 更安全？

### 1.1 HTTPS 简介
- **HTTPS = HTTP + SSL/TLS**，是在 HTTP 协议基础上通过 SSL/TLS 实现加密传输的安全协议。
- 主要用于保障客户端与服务器之间的数据安全。

### 1.2 HTTPS 的核心目标
- **加密**：防止中间人窃听明文数据（如密码、token）。
- **身份认证**：确保客户端访问的服务器是真实的，防止钓鱼网站。
- **数据完整性**：防止数据在传输过程中被篡改。

### 1.3 HTTPS 的工作流程（简化版）
1. **客户端发起请求**：浏览器访问 https:// 网站，发起 SSL/TLS 握手。
2. **服务器返回证书**：服务器将自己的公钥证书（包含公钥、颁发者信息等）返回给客户端。
3. **客户端验证证书合法性**：检查证书是否被信任的 CA 签发、域名是否匹配、证书是否过期。
4. **协商对称加密密钥**：客户端生成对称密钥，用服务器的公钥加密后发给服务器，只有服务器的私钥能解密。
5. **数据通信使用对称加密**：双方都拥有同一个对称加密密钥，之后的 HTTP 通信内容就是加密的。

### 1.4 HTTPS 比 HTTP 更安全的 3 个核心原因
#### ① 通信加密（Confidentiality）
- **HTTP**：明文传输，任何中间人（如 Wi-Fi 热点、运营商）都可以看到请求内容（用户名、密码、token、表单数据等）。
- **HTTPS**：使用对称加密（如 AES），通信内容被加密，即使被拦截也无法读取。

#### ② 身份认证（Authentication）
- **HTTPS**：使用数字证书（由权威 CA 签发）来证明服务器真实身份。
- 客户端在握手时会验证服务器证书是否合法、域名是否一致、是否过期，防止钓鱼网站。

#### ③ 数据完整性保护（Integrity）
- **HTTPS**：通信过程中使用消息摘要算法（如 SHA-256）和 MAC 校验，确保数据未被中间人篡改。
- 即使攻击者劫持了数据，也无法对内容进行修改而不被发现。

### 1.5 HTTPS 与 HTTP 的区别
| 方面     | HTTP                | HTTPS                          |
| -------- | ------------------- | ------------------------------ |
| 安全性   | 明文传输，不安全     | 加密传输，防窃听、防篡改        |
| 端口     | 默认使用 80         | 默认使用 443                   |
| 证书支持 | 不需要              | 需要 SSL 证书（可付费或免费）   |
| 性能     | 较快                | TLS 握手阶段略慢，现已优化      |

### 1.6 开发者关注点
- **HSTS（HTTP Strict Transport Security）**：防止协议降级攻击。后端可以在响应头中设置 Strict-Transport-Security，强制客户端始终用 HTTPS
- **Mixed Content 警告**：页面使用 HTTPS，但引用了 HTTP 的资源（如图片、脚本）会被浏览器阻止或警告
- **证书更新/自动化**：Let’s Encrypt 提供免费证书，搭配自动化工具（如 Certbot）进行更新，降低维护成本
- 浏览器地址栏出现 🔒 锁标志，表示当前网站可信、连接加密

---

## 2. HTTP 缓存

### 2.1 强缓存
- 不请求服务器，直接使用本地缓存
#### 响应头
1. **Cache-Control**
- 是现代浏览器主要的缓存控制方式，优先级高于Expires
- 常见指令：
  - max-age=3600: 缓存有效期为 3600 秒
  - no-store：禁止缓存
  - no-cache：允许缓存但必须向服务器验证
  - public：可被任何中间缓存服务器缓存
  - private：仅浏览器缓存，CDN 不可缓存
2. **Expires**
- 老版本 HTTP/1.0 使用，指定一个绝对时间（GMT 格式），超出则缓存失效
- 和 max-age 不同，容易受客户端时间影响
### Cache-control示例
1. **Cache-Control: public, max-age=31536000, immutable**
- **public**：允许中间缓存（CDN、浏览器）缓存
- **max-age=31536000**：缓存 1 年（秒为单位）
- **immutable**：表明资源永远不会改变，浏览器不会发起条件请求
2. **Cache-Control: private, max-age=600**
- **private**：缓存仅对用户的浏览器有效，中间缓存（如 CDN）不能缓存
- **max-age=600**：浏览器可缓存 10 分钟
3. **Cache-Control: public**
- 缓存是否生效取决于其他缓存头（如 Expires、ETag）
### 判断方式
- 浏览器访问资源时，如果强缓存生效，不会向服务器发请求，状态码为 200 (from disk cache) 或 200 (from memory cache)

### 2.2 协商缓存
- 发送请求，服务器确认是否需要重新下载
- 当强缓存失效后，浏览器会向服务器发起请求，并带上上一次缓存的标识信息，服务器判断资源是否变更
### 请求头和响应头
1. **Last-Modified（响应头） 和 If-Modified-Since（请求头）**
- 服务端返回资源的最后修改时间
- 下次请求时，浏览器带上 If-Modified-Since
- 服务端比较修改时间是否有变，如果没变返回 304，否则返回新资源
2. **ETag（响应头） 和 If-None-Match（请求头）**
- ETag 是资源内容的唯一标识符（可以是哈希
- 浏览器下次请求带上 If-None-Match，服务端验证是否一致
- 一致则返回 304；否则返回新内容并更新 ETag
>**⚠️ 注意：** 相比 Last-Modified，ETag 更准确，即使资源时间未变但内容有小改动，也能识别。

### 强缓存和协商缓存的关系
#### 浏览器缓存流程顺序：
1. **先查强缓存（Cache-Control / Expires）**
- 命中 → 直接使用
2. **强缓存失效后走协商缓存（ETag / Last-Modified）**
- 若资源未变 → 服务器返回 304 → 浏览器使用本地缓存
- 若资源已变 → 服务器返回 200 → 浏览器更新缓存

### 开发中的延伸点
- 即使服务器返回了 ETag 和 Last-Modified，只有当强缓存失效（如 max-age 到期）后，浏览器才会走协商缓存
- 如果资源设置了长效 Cache-Control: max-age=31536000，就算有 ETag，通常也不会走协商缓存
- 浏览器缓存策略由多因素共同决定，不仅是响应头，还和用户行为、开发者工具（Disable Cache）、缓存空间策略等有关

---

## 3. DNS 解析涉及到的协议
### 相关协议
1. **UDP协议**
- 默认是使用的传输层协议
- DNS查询的首选协议，端口号：53
- 原因：UDP 是无连接的，开销小、速度快，适合简单的一问一答场景
- 特点：数据包小于 512 字节（传统 DNS，IPv4 环境），客户端向 DNS 服务器发起请求，服务器直接返回结果
2. **TCP协议**
- 当以下情况发生时，DNS 会自动从 UDP 切换为 TCP：
  - 响应数据超过 UDP 限制（现代支持 EDNS，可达 4096 字节，但仍有上限）
  - 进行区域传输（zone transfer）时，必须使用 TCP
  - 某些 DNS 查询要求可靠性保障（如 DNSSEC）
3. **IP协议**
- DNS 请求和响应最终通过 IP 协议在网络上传输
- IPv4 or IPv6 决定了目标 DNS 服务器的寻址方式
4. **ICMP协议**
- 不直接用于 DNS 解析
- 但在排查 DNS 失败或网络延迟时（如 ping、traceroute）经常用于辅助诊断
- 有助于了解 DNS 请求到底卡在哪一跳（比如 ping 不通 DNS 服务器）
### DNS解析过程
1. **本地缓存检查**
- **浏览器 DNS 缓存**：如 Chrome 自带的缓存（可查看 chrome://net-internals/#dns）
- **操作系统缓存**：如 Windows 的 DNS 缓存 (ipconfig /displaydns)
- **本地 Hosts 文件**：/etc/hosts 或 C:\Windows\System32\drivers\etc\hosts
2. **本地DNS服务器**
- 通常是你所在网络提供的 DNS（如 114.114.114.114、8.8.8.8），它会帮你递归查找最终 IP，返回结果后缓存一段时间
3. **根域名服务器**
- 如果本地 DNS 服务器也没缓存，它会问全球 13 个 根 DNS 服务器，返回 .com 顶级域服务器地址
4. **顶级域名服务器（TLD）**
- 返回 example.com 的权威服务器地址
5. **权威 DNS 服务器**
- 返回 www.example.com 对应的 IP 地址
6. **总结**
- DNS 解析是将域名转换为 IP 地址的过程，浏览器会先查本地缓存，如果没有命中，就向递归 DNS 服务器发起查询，再由它逐级从根服务器、TLD 服务器、权威服务器查询 IP 地址，最终返回结果并缓存。DNS 查询是浏览器访问网站的第一步，对性能有重要影响。DNS 查询是性能优化关键（可结合 DNS 预获取 `<link rel="dns-prefetch">`）

---

## 4. 应用层的协议
HTTP、HTTPS、FTP、SMTP、POP3、IMAP、DNS、WebSocket 等
1. **Web 通信相关**
- **✅HTTP / HTTPS**
- 用途：浏览器与服务器之间通信的主流协议
- 端口：80（HTTP），443（HTTPS）
- 特性：
  - 基于请求/响应模型
  - 无状态
  - 支持 GET、POST、PUT、DELETE 等方法
- **✅WebSocket**
- 用途：实现浏览器与服务器之间的双向通信（长连接）
- 端口：通常也是 80（ws）或 443（wss）
- 特性：
  - 建立在 HTTP 基础之上，通过升级协议握手
  - 支持实时应用，如聊天室、股票行情、游戏等 
2. **文件传输 / 下载相关**
- **✅FTP（File Transfer Protocol）**
- 用途：在服务器和客户端之间传输文件
- 端口：21（控制连接），20（数据连接）
- 特点：
  - 明文传输（有安全隐患），可用 FTPS/SFTP 加密
  - 常用于网站部署、资源同步
- **✅HTTP(S) 下载**
- 虽不是专用文件协议，但现代大部分文件下载也通过 HTTP(S)
3. **邮件相关**
- **✅SMTP（Simple Mail Transfer Protocol）**
- 用途：用于发送邮件
- 端口：25、465（SSL）、587（STARTTLS）
- **✅POP3 / IMAP**
- POP3（端口 110）：邮件拉取到本地后服务器删除
- IMAP（端口 143）：服务器保留副本，支持多设备同步查看邮件
4. **域名解析 / 网络服务**
- **✅DNS（Domain Name System）**
- 用途：将域名解析为 IP 地址
- 端口：53（UDP/TCP）
- 扩展：支持加密版本 DoH（HTTPS）、DoT（TLS）

---

## 5. UDP 协议
✅ 一句话概括： UDP（User Datagram Protocol）是传输层的无连接协议，特点是速度快、开销小，但不保证可靠性
1. **基本特点**
- **无连接**：不建立连接，直接发送数据（不像 TCP 三次握手）
- **不可靠**：不保证数据一定送达，也不保证顺序和去重
- **面向报文**：一次发送一个完整数据包，应用需自行处理分片
- **速度快**： 没有连接管理和重传机制，延迟小、效率高
- **无拥塞控制**： 不主动限流，适合实时场景但可能丢包
2. **工作方式**
- 不需要建立连接，直接发送数据包到目标地址和端口
- 每个数据包叫做“报文段（datagram）”
- 接收方收到的可能是乱序的、重复的、甚至收不到（丢包）
- 没有流量控制和拥塞控制，完全靠应用层控制逻辑
3. **典型应用场景**
- **DNS 查询**：体积小，速度要求高
- **视频直播**：偶尔丢帧也可接受，实时性重要
- **VoIP 通话**：对实时性要求高，不适合重传
- **在线游戏**：响应快优于可靠传输
- **DHCP 协议**： 网络初始化期间使用 UDP 广播
4. **UDP vs TCP**

| 特性         | UDP                          | TCP                              |
| ------------ | --------------------------- | --------------------------------- |
| 是否连接     | ❌ 无连接                     | ✅ 面向连接（三次握手）            |
| 可靠性       | ❌ 不保证可靠、不保证顺序      | ✅ 保证可靠、有序、无重复传输      |
| 速度         | ✅ 快，延迟低                  | ❌ 相对慢，需连接和确认            |
| 拥塞/流量控制 | ❌ 无                         | ✅ 有                              |
| 报文大小限制 | 单个报文 ≤ 65,535 字节        | 自动分段，理论无限                |
| 应用场景     | 实时性优先（直播、游戏、DNS） | 可靠性优先（网页、文件、邮件等

5. **前端视角下如何“接触”到 UDP**
- DNS 查询（大多数用 UDP）
- WebRTC：浏览器的实时音视频通信，底层基于 UDP + SRTP
- CDN 加速 / 视频直播：UDP 提供低延迟传输，前端体验依赖 UDP 质量
- 网络诊断工具：如 ping、traceroute 有时依赖 UDP 包探测

---

## 6. TCP 三次握手，为什么一定需要三次握手？
✅ 一句话概括： 三次握手的本质目的是 确保客户端和服务器双方都有“接收”和“发送”能力正常，确保连接的可靠性。
### 三次握手流程
1. **第一次握手**（客户端 → 服务器）
- 客户端发送一个带 SYN 标志位的报文，请求建立连接（我能发送）。
2. **第二次握手**（服务器 → 客户端）
- 服务器收到请求，返回一个 SYN + ACK 报文，表示（确认客户端能发送）：
  - 收到了客户端的 SYN（我能接收）
  - 自己也发起了连接请求（我能发送） 
3. **第三次握手**（客户端 → 服务器）
- 客户端收到 SYN+ACK 后，发送一个 ACK 报文，表示（确认服务端能接受和发送）：
  - 收到服务器的响应（我能接收）
  - 确认连接可以正式建立 

### 为什么不能两次握手
假设：只有两次握手
- 第一次：客户端发送 SYN
- 第二次：服务器收到，回复 SYN+ACK
- 没有第三次，客户端不再响应  
此时，服务器不知道客户端是否收到了自己发的 SYN+ACK，也不知道客户端是否准备好收发数据。  
⚠️ 这可能会导致：
- 服务器误以为连接已建立（而客户端实际未确认）
- 服务器为这个连接分配资源，但客户端并未准备好使用
- 导致资源浪费，甚至成为攻击点（例如 SYN Flood 攻击）

### 为什么不是四次握手
实际上 三次就足够，因为：
- 第二次握手中，服务器就已经同时完成了两个动作
  - 确认客户端的连接请求（ACK）
  - 发起自己的连接请求（SYN）
- 如果把 ACK 和 SYN 拆成两次，那确实就会变成四次握手，但效率更低，而没有必要

---
